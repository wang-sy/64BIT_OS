# 64位操作系统——（四）处理器体系结构

在前三个章节中，我们实现了一个简单的操作系统。这个操作系统有最最简单的内存管理、进程切换的方法，当然这些方法非常简陋。在后面的章节中，我们会跟随作者的书，继续去完善我们的系统。在这一节中，我们先学习一些有关当前的`intel`体系结构的东西。

这些知识都是我从作者那里接受过来的知识，然后再输出到文档里面，如果你看我写的文档，那大概属于二手知识了。所以我还是建议你直接去看作者的书，如果有理解不了的地方，来看看这个文档作为辅助理解是最好的。当然，我也不会把所有的内容都写上来，而是将一些我认为遇到过、有用的知识写上来。



## 基础功能与新特性

这一节主要讲的是`Intel Pentium 4`以及后续的处理器的特性



### 运行模式

我们先来回想一下，在bootloader中我们在几个模式之间进行了切换？

<img src="pics/lab4/image-20201112015426679.png" alt="image-20201112015426679" style="zoom:67%;" />

那么在此基础上，我们来了解一下`intel cpu`为我们提供了哪些运行模式：

- **实模式**：这个就是我们完成Bios自检后留存的模式，在该模式下，cpu处于`16位宽`状态，同时只有20工作的根地址线，所以只能访问`1MB`内存，当然，我们也可以打开`Big Real Mode`模式来操作`4GB`内存范围内的数据，至于`Big Real Mode`如何运行，我们后面再做讲解。
- **保护模式**：这个是三十二位处理器运行的主要模式，特征是可以访问`4GB`的数据，及`4GB`的代码（`Big Real Mode`只能跑`1MB`代码，所以才叫`Real Modd`）
- **系统管理模式** ：这个没有接触过，相当于是处理器提供给操作系统的接口，这个接口可以用于电源管理等，当调用这一系列接口的时候，CPU就会陷入系统管理模式（这和系统调用很相似，不同的是服务的提供者）
- **虚拟8086模式**：处理器为保护模式提供的一种运行模式，允许处理器在保护模式下执行8086软件和多任务环境。（猜测是）
- **IA-32e模式**：64为处理器的主要运行模式，包含兼容模式和64位模式两种主要模式。



作者给出了一张图，这张图描述了不同模式之间的转移方法：

<img src="pics/lab4/image-20201112021247046.png" alt="image-20201112021247046" style="zoom:67%;" />

我们用到了标红的两种转移。同时，如果想要检测计算机是否在`IA-32e`模式，只需要检测`IA32_EFER`寄存器的`LME`位是否为1即可。



### 通用寄存器

对于一个32位CPU，一共有八个通用寄存器：

`EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP`

我们最熟悉的是`ESP`，他负责记录当前执行程序的栈指针，我们不能随便改他，除此之外，这些寄存器还有一些特殊用途：

> | 名称 | 特殊功能描述                                     |
> | :--- | :----------------------------------------------- |
> | EAX  | 用于累加操作或保存计算结果                       |
> | EBX  | 作为DS数据段寄存器的段内偏移指针                 |
> | ECX  | 字符串和循环操作的计数器                         |
> | EDX  | I/O地址指针                                      |
> | ESI  | 作为DS数据段寄存器的段内偏移指针（源地址指针）   |
> | EDI  | 作为ES数据段寄存器的段内偏移指针（目标地址指针） |
> | ESP  | 栈指针                                           |
> | EBP  | 栈帧（段内偏移指针）                             |



对于64位CPU而言，`Intel`多给了8个寄存器：

`RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP`

可以看到，这八个寄存器和上面的是对应的，引用博客[RAX,eax,ax,ah,al 关系](https://blog.csdn.net/qwq1503/article/details/100108831)中的一个图，他们的关系非常好说明：

```
|63..32|31..16|15-8|7-0|
               |AH.|AL.|
               |AX.....|
       |EAX............|
|RAX...................|
```



### CPUID指令



#### 检测是否支持CPUID指令

通过EFLAGS标志寄存器的ID标志位（位于EFLAGS寄存器的第21位）可检测出处理器是否支持`CPUID`指令。

#### CPUID查询指令

首先看这张图：

<img src="pics/lab4/07.d06z.002.png" alt="img" style="zoom: 33%;" />

cpuid 指令由 eax 寄存器获得输入，执行 cpuid 指令前，将功能号传给 eax 寄存器:

输入：

- eax：主功能号，支持的最大主功能号是14h
- ecx：扩展信息的主功能号， 从80000000h到80000008h

输出：

- eax
- ebx
- ecx
- edx



我们在检测是否支持CPUID指令的时候用到了`EFLAGS标志寄存器`，我们来了解下：

### EFLAGS标志寄存器

<img src="pics/lab4/07.d06z.003.png" alt="img" style="zoom: 80%;" />

我们刚才检测是否支持`CPUID`的时候，检测的是EFLAGS寄存器的第21位：ID位，它的作用就是标记CPU是否支持`CPUID`指令。

EFLAGS标志寄存器的值可以通过特殊的汇编指令进行更改。当程序通过**调用门执行任务切换时**，处理器会把EFLAGS标志寄存器值**保存到任务状态段TSS内**，并将目标任务状态段TSS内的值**更新到EFLAGS标志寄存器**中。可以根据标志位功能将他们分为：**状态标志、方向标志、系统标志和IOPL区域等几部分**：

#### 状态标志

状态标识用于反应运算结果的特征，如下，（表来源于作者书）：

> <img src="pics/lab4/image-20201112031633947.png" alt="image-20201112031633947" style="zoom:80%;" />

破案了，我们之前用的各种判断CF、ZF的条件跳转就是判断`EFLAGS标志寄存器`相应位的值，其中有一些技巧：

- CF标志位可反映出有符号整型数计算结果的溢出状态
- AF标志位可反映出BCD整型数计算结果的溢出状态
- SF标志位可反映出有符号整型数计算结果的正负值
- ZF标志位可反映出整型数（有符号和无符号）的计算结果

在上面的标识中，只有CF标志位可通过`STC`、`CLC`和`CMC`汇编指令更改位值，它也可借助位操作指令将指定位值复制到CF标志位。



#### 方向标志

`DF`就是方向标识，它控制着字符串指令的操作方向。`DF == 1`可使字符串指令按从高至低的地址方向，反之则反。汇编指令`STD`与`CLD`可用于置位和复位DF方向标志位。（我们之前用过这个）



#### 系统标志和IOPL区域

这些位负责控制I/O端口地址访问权限、屏蔽硬件中断请求、使能单步调试、任务嵌套以及使能虚拟8086模式等，其功能如下：

> | 缩写 | 全称                              | 位置  | 功能描述                    |
> | :--- | :-------------------------------- | :---- | :-------------------------- |
> | TF   | Trap                              | 8     | 使能单步调试功能            |
> | IF   | InterruptEnable                   | 9     | 使能中断（响应可屏蔽中断）  |
> | IOPL | I/O Privilege Level Field         | 12,13 | 访问I/O端口地址的最低特权级 |
> | NT   | Nested Task                       | 14    | 允许任务嵌套调用            |
> | RF   | Resume                            | 16    | 允许调试异常                |
> | VM   | Virtual-8086 Mode                 | 17    | 使能Virtual-8086模式        |
> | AC   | Alignment Check or Access Control | 18    | 数据对齐检测                |
> | VIF  | Virtual Interrupt                 | 19    | IF中断使能标志位的虚拟镜像  |
> | VIP  | Virtual interrupt pending         | 20    | 中断挂起                    |
> | ID   | Identification                    | 21    | 检测`CPUID`指令             |

需要注意的是：如果希望**修改上述系统标志位或IOPL区域**，则**必须拥有足够的执行权限**（0特权级）。